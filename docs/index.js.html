<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Crypto.html">Crypto</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base32Decode">base32Decode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base32Encode">base32Encode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base64Decode">base64Decode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base64Encode">base64Encode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base64UrlDecode">base64UrlDecode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.base64UrlEncode">base64UrlEncode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.decrypt">decrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.encrypt">encrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.hash">hash</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.hmac">hmac</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.privateDecrypt">privateDecrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.privateEncrypt">privateEncrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.publicDecrypt">publicDecrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.publicEncrypt">publicEncrypt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.sign">sign</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Crypto.html#.verify">verify</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const crypto = require("crypto");

/**
 *
 */
class Crypto {
    // crypto

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.algorithm=aes256
     * @param {String} options.key
     * @param {String} options.iv
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static encrypt(data, options = {}) {
        const { algorithm = "aes256", key = "", iv = "", encoding = "hex" } = options;
        const cipher = crypto.createCipheriv(algorithm, key, iv);
        return Buffer.concat([cipher.update(data), cipher.final()]).toString(encoding);
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.algorithm=aes256
     * @param {String} options.key
     * @param {String} options.iv
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static decrypt(data, options = {}) {
        const { algorithm = "aes256", key = "", iv = "", encoding = "hex" } = options;
        const cipher = crypto.createDecipheriv(algorithm, key, iv);
        return Buffer.concat([cipher.update(data, encoding), cipher.final()]).toString();
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static privateEncrypt(data, options = {}) {
        const { privateKey = "", encoding = "hex" } = options;
        data = Buffer.from(data);
        return crypto.privateEncrypt(privateKey, data).toString(encoding);
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static privateDecrypt(data, options = {}) {
        const { privateKey = "", encoding = "hex" } = options;
        data = Buffer.from(data, encoding);
        return crypto.privateDecrypt(privateKey, data).toString();
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static publicEncrypt(data, options = {}) {
        const { publicKey = "", encoding = "hex" } = options;
        data = Buffer.from(data);
        return crypto.publicEncrypt(publicKey, data).toString(encoding);
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static publicDecrypt(data, options = {}) {
        const { publicKey = "", encoding = "hex" } = options;
        data = Buffer.from(data, encoding);
        return crypto.publicDecrypt(publicKey, data).toString();
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.algorithm=sha256
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static sign(data, options = {}) {
        const { algorithm = "sha256", privateKey = "", encoding = "hex" } = options;
        const writable = crypto.createSign(algorithm);
        writable.write(data);
        writable.end();
        return writable.sign(privateKey, encoding);
    }

    /**
     *
     * @param {String} data
     * @param {String} signature
     * @param {Object} options
     * @param {String} options.algorithm=sha256
     * @param {String} options.privateKey
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static verify(data, signature, options = {}) {
        const { algorithm = "sha256", privateKey = "", encoding = "hex" } = options;
        const writable = crypto.createVerify(algorithm);
        writable.write(data);
        writable.end();
        return writable.verify(privateKey, signature, encoding);
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.algorithm=sha256
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static hash(data, options = {}) {
        const { algorithm = "sha256", encoding = "hex" } = options;
        return crypto.createHash(algorithm).update(data).digest(encoding);
    }

    /**
     *
     * @param {String} data
     * @param {Object} options
     * @param {String} options.algorithm=sha256
     * @param {String} options.key
     * @param {String} options.encoding=hex
     * @returns {String}
     */
    static hmac(data, options = {}) {
        const { algorithm = "sha256", key = "", encoding = "hex" } = options;
        return crypto.createHmac(algorithm, key).update(data).digest(encoding);
    }

    // base64
    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base64Encode(data) {
        return Buffer.from(data).toString("base64");
    }

    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base64Decode(data) {
        return Buffer.from(data, "base64").toString();
    }

    // base64Url
    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base64UrlEncode(data) {
        return Buffer.from(data).toString("base64Url");
    }

    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base64UrlDecode(data) {
        return Buffer.from(data, "base64Url").toString();
    }

    // base32
    // https://www.rfc-editor.org/rfc/rfc4648
    static base32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base32Encode(data) {
        data = Buffer.from(data);

        let alphabet = this.base32Alphabet;
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        let bits = 0;
        let value = 0;
        let output = "";

        for (let i = 0; i &lt; view.byteLength; i++) {
            value = (value &lt;&lt; 8) | view.getUint8(i);
            bits += 8;

            while (bits >= 5) {
                output += alphabet[(value >>> (bits - 5)) &amp; 31];
                bits -= 5;
            }
        }

        if (bits > 0) {
            output += alphabet[(value &lt;&lt; (5 - bits)) &amp; 31];
        }

        while (output.length % 8 !== 0) {
            output += "=";
        }

        return output;
    }

    /**
     *
     * @param {String} data
     * @returns {String}
     */
    static base32Decode(data) {
        data = data.replace(/=+$/, "");

        let alphabet = this.base32Alphabet;
        let length = data.length;
        let bits = 0;
        let value = 0;
        let index = 0;
        let output = new Uint8Array(((length * 5) / 8) | 0);

        for (let i = 0; i &lt; length; i++) {
            value = (value &lt;&lt; 5) | alphabet.indexOf(data[i]);
            bits += 5;

            if (bits >= 8) {
                output[index++] = (value >>> (bits - 8)) &amp; 255;
                bits -= 8;
            }
        }

        return Buffer.from(output).toString();
    }
}

module.exports = Crypto;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Wed Aug 17 2022 12:21:01 GMT+0700 (Western Indonesia Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
